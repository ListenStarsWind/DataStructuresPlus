# 图

## 图的基本概念

首先, 图有两个最最基本的概念, 那就是顶点和边, 图通过边来描述多个顶点之间的关系. 因此, 图常被表示为`G == (V, E)`, 其中`G`为`Graph`(图)的缩写, `V`就是顶点`Vertex `, `E`就是边`Edge`

顶点集合`V = {x|x属于某个数据对象集}`是有穷非空集合； `E = {(x,y)|x,y属于V}`或者`E = {<x, y>|x,y属于V && Path(x, y)}`是顶点间关系的有穷集合，也叫做边的集合 .

下面是一些常见的图

![image-20250510203707126](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250510203707201.png)

树是一种特殊的图. 树关注节点(也就是顶点)中存的值, 图关注的是顶点以及边的权值, 权值用来表示图中节点关系的程度, 姑且这样说.

边还分有向和无向两种, 有向表示关系是相互的, 无向表示关系是单向的.比如上面的`G3`, 只能是`0`到`1`, `1`到`2`, `1`到`0`, 但`2`到不了`1`. 图具有很强的现实意义, 比如它可以表示交通网络图

![image-20250510204753405](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250510204753443.png)

在这张图中, 每个顶点都表示着某个城市, 边上的权值则表示综合的交通花费, 可能表示从一个城市到另一个城市的交通代价. 此时就有很多题目, 要你去求最短路径这种, 我已经刷过一些题了, 在我看来, 这并不多么抽象. 怎么求最短路径, 什么动规, 深搜, 宽搜, 这还是最简单的那一批.

## 图的存储结构

图有两种描述方式, 或者说存储结构, 它们各有各的优缺点, 我们先说邻接矩阵. 

邻接矩阵是一个`n * n`大小的二维数组, 描述了`n`个顶点之间的边及其权值, 

![image-20250510212808808](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250510212808869.png)

比如这里, 字符`A, B, C, D`所对应的编号分别是`0, 1, 2, 3`, 当我们想要查询`A`到`B`方向的边是什么情况, 只需要查询一下, 矩阵`[0,1]`位置是什么值, 我们看到是`1`, 那这一方面表示`A`到`B`是有边的, 另一方面, 表示边权为一, 上面的这张图是一张边权为一的无相图, 矩阵中的数值`1`表示两个顶点相连, 数值`0`表示两个顶点不相连, 或者说没有实际意义, 比如`[3, 1]`这个位置是`0`, 那就意味着, `D`到`B`是没有边的, 像`[n,n]`这种在对角线上的, 那就是没有意义的, 表示自己到自己的关系.

邻接矩阵的优势在于可以常数时间复杂度快速自然地查询一个点到另一个点的关系. 并且, 他对于稠密图, 就是很多边的图, 一个顶点可能与其他顶点都相连, 也有很高的适配性, 毕竟邻接矩阵穷举了所有的连接可能.

如果不是边权为一的, 就是边权不是相同的, 不可以抽象成一个单位一, 那就用矩阵中的值表示边权, 用一个不可能的数, 没有实际意义的值, 比如, 极大值, 极小值来表示没有相连的边

![image-20250510214111934](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250510214111985.png)

`[0,2]`是无穷, 或者说是`W_MAX, W_MIN`, `W`表示权值, `weight`, 这就表示, `0`到`2`没有边, `[2,0]`是`3`, 表示`2`到`3`有边, 且边权为3.

另外我们可以看出来的就是, 对于无向图, 就是边是双向导通的, 只要`V1`到`V2`是连接的, 那么`V2`到`V1`也一定是连接的, 因此, 邻接矩阵关于对角线对称, 而对于有向图来说, 边的方向是单向的, 所以就不一定呈现对称结构.

链接矩阵的劣势时, 现在我在一个顶点, 想到达下一个顶点, 这时候就需要看这个顶点连接了哪些点, 从这段话也能看出, 这张图是有向的, 此时对于邻接矩阵就需要把整个一行给遍历一下.

所以就有了邻接表, 邻接表的最原始形态是`vector<int, vector<int>>`, 前面的`int`表示顶点的编号, 后面的`vector<int>`表示其下一个顶点的编号. 也就是描述出边, 出边就是出去的边, 方向对外的那些边.

![image-20250510215632793](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250510215632848.png)

一般来说, 邻接表只要有出边表就行了, 不需要有入边表.

下面我们先简单实现一下邻接矩阵版本的

```cpp
namespace matrix {

    // 默认无向图
    template <class V, class W, W MAX_W = INT_MAX, bool Directed = false>
        class Graph
        {
            public:
            // 对于图的构造, 常见的有三种模式
            // 有些OJ题喜欢直接用标准输入构造
            // 有些喜欢写配置文件, 读文件构造
            // 我们这里一方面为了省事
            // 一方面为了便于修改, 选择
            // 第三种方式, 最开始只加顶点, 边后面加
            Graph(const V* data, int n)
            {
                _data.reserve(n);
                for (int i = 0; i < n; ++i)
                {
                    _index_map[data[i]] = i;
                    _data.emplace_back(data[i]);
                }

                _matrix.resize(n, std::vector<W>(n, MAX_W));
            }

            int GetVertexIndex(const V& z)
            {
                auto it = _index_map.find(z);

                if (it == _index_map.end())
                    throw std::out_of_range("unordered_map::at: key not found");

                return _index_map[z];
            }

            void ModEdge(const V& x, const V& y, W n)
            {
                int src = GetVertexIndex(x);
                int dst = GetVertexIndex(y);

                _matrix[src][dst] = n;

                // 如果是有向图
                if (Directed == false)
                    _matrix[dst][src] = n;
            }

            void Print() const
            {
                // Step 1: 计算最大数字宽度
                int max_width = 1;
                for (const auto& row : _matrix)
                {
                    for (const W& w : row)
                    {
                        if (w != MAX_W)
                        {
                            std::ostringstream oss;
                            oss << w;
                            max_width = std::max(max_width, static_cast<int>(oss.str().length()));
                        }
                    }
                }

                // 非边字符 "#" 也要考虑宽度
                max_width = std::max(max_width, 1);  // 至少为1

                // Step 2: 打印编号与数据对应关系
                std::cout << "Vertex Index:\n";
                for (size_t i = 0; i < _data.size(); ++i) std::cout << "[" << i << "] " << _data[i] << "  ";
                std::cout << "\n\n";

                // Step 3: 打印列标题（编号而不是 _data）
                std::cout << std::string(max_width + 1, ' ');
                for (size_t i = 0; i < _data.size(); ++i) std::cout << std::setw(max_width + 1) << i;
                std::cout << "\n";

                // Step 4: 打印矩阵内容（行首也用编号）
                for (size_t i = 0; i < _matrix.size(); ++i)
                {
                    std::cout << std::setw(max_width) << i << " ";
                    for (size_t j = 0; j < _matrix[i].size(); ++j)
                    {
                        if (_matrix[i][j] == MAX_W)
                            std::cout << std::setw(max_width + 1) << "#";
                        else
                            std::cout << std::setw(max_width + 1) << _matrix[i][j];
                    }
                    std::cout << "\n";
                }
            }

            private:
            std::vector<V> _data;
            std::unordered_map<V, int> _index_map;
            std::vector<std::vector<W>> _matrix;
        };
}  // namespace matrix
```

那个`print`不是我写的, 直接拷贝就行, 据说可以自动适应边权长度, 动态调整

```cpp
void TestGraph()
{
    matrix::Graph<char, int, INT_MAX, true> g("0123", 4);
    g.ModEdge('0', '1', 1);
    g.ModEdge('0', '3', 4);
    g.ModEdge('1', '3', 2);
    g.ModEdge('1', '2', 9);
    g.ModEdge('2', '3', 8);
    g.ModEdge('2', '1', 5);
    g.ModEdge('2', '0', 3);
    g.ModEdge('3', '2', 6);
    g.Print();
}

int main()
{
    TestGraph();
    return 0;
}
```

```shell
[whisper@starry-sky build]$ ./a.out 
Vertex Index:
[0] 0  [1] 1  [2] 2  [3] 3  

   0 1 2 3
0  # 1 # 4
1  # # 9 2
2  3 5 # 8
3  # # 6 #
[whisper@starry-sky build]$ 
```

在通过代码对图有基本的认识之后, 我们可以进一步去了解图的其他概念.

- **完全图**

  在有`n`个顶点的无向图中，若有`n * (n-1)/2`条边，即任意两个顶点之间有且仅有一条边，则称此图为无向完全图，比如下图`G1`；在`n`个顶点的有向图中，若有`n * (n-1)`条边，即任意两个顶点之间有且仅有方向相反的边，则称此图为有向完全图

  ![image-20250512113428065](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250512113428147.png)

  对于有向图来说, 我们看邻接矩阵, 相当于邻接矩阵的每一行除了它自身, 也就是那个对角线, 之外, 都有边, 一共有`n`行, 每行`n-1`个边, 所以边的总数就是`n*(n-1)`  而对于无向图来说, 由于他把两个顶点之间方向相反的边合并为一条, 所以是`n*(n-1) / 2`

  完全图是最稠密的图.

- 邻接顶点

  在无向图中G中，若`(u, v)`是`E(G)`中的一条边，则称`u`和`v`互为邻接顶点，并称边`(u,v)`依附于顶点`u`和`v`；在有向图G中，若`<u, v>`是`E(G)`中的一条边，则称顶点`u`邻接到`v`，顶点`v`邻接自顶点`u`，并称边`<u, v>`与顶点`u`和顶点`v`相关联  

- **顶点的度**

  顶点`v`的度是指与它相关联的边的条数，记作`deg(v)`。在有向图中，顶点的度等于该顶点的入度与出度之和，其中顶点`v`的入度是以`v`为终点的有向边的条数，记作`indev(v)`;顶点`v`的出度是以`v`为起始点的有向边的条数，记作`outdev(v)`。因此：`dev(v) = indev(v) + outdev(v)`注意：对于无向图，顶点的度等于该顶点的入度和出度，即`dev(v) = indev(v) = outdev(v)`

- **路径**

  在图`G = (V， E)`中，若从顶点`vi`出发有一组边使其可到达顶点`vj`，则称顶点`vi`到顶点`vj`的顶点序列为从顶点`vi`到顶点`vj`的路径。

  ![image-20250512120734210](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250512120734311.png)

  比如在这张图中, `6`到`7`的路径是`6,7`, `1`到`7`的路径是`1,3,6,7`或者`1,4,7`, 没有哪个节点有到`1`的路径, 因为`1`的边全部都是出边.  另外我们看到, 从一个顶点到另一个顶点有多条路径, 此时就需要进行选择, 选择其中边权和最小的那条路径. 怎么求最短路径, 将会是本文的一个重点

- **路径长度**

  对于不带权的图，一条路径的路径长度是指该路径上的边的条数；对于带权的图，一条路径的路径长度是指该路径上各个边权值的总和.

- 简单路径和回路

  若路径上各顶点`v1，v2，v3，…，vm`均不重复，则称这样的路径为简单路径。

  若路径上第一个顶点`v1`和最后一个顶点`vm`重合，则称这样的路径为回路或环

  ![image-20250512121822544](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250512121822593.png)

- **子图**

  设图`G = {V, E}`和图`G1 = {V1，E1}`，若`V1`属于`V`且`E1`属于`E`，则称`G1`是`G`的子图, 又或者说, 子图中的顶点和边都是原图边顶点的一部分

  ![image-20250512122015321](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250512122015370.png)

- **连通图**

  在无向图中，若从顶点`v1`到顶点`v2`有路径，则称顶点`v1`与顶点`v2`是连通的。如果图中任意一对顶点都是连通的，则称此图为连通图

- **强连通图**

  在有向图中，若在每一对顶点`vi`和`vj`之间都存在一条从`vi`到`vj`的路径，也存在一条从`vj`到`vi`的路径，则称此图是强连通图, 有向图的连通比无向图困难, 所以称之为"强连通图".

- **生成树**

  一个连通图(连通图是无向图里的概念)的最小(用最少的边)连通子图称作该图的生成树。有n个顶点的连通图的生成树有n个顶点和n- 1条边. 对于一个无向图来说, `n`个顶点有`n-1`个间隔, 每个间隔都需要用一条边连接起来, 所以生成树边的个数是`n-1`.

  ![image-20250512124134181](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250512124134249.png)

  我们看到, 一个无向图会有多个生成树

- **最小生成树**

  在生成树的基础上, 其中所有的边, 边权和最小的那个生成树, 就是最小生成树.

下面, 我们写一下基于邻接表的图, 在后面, 考虑到邻接矩阵对于更复杂图的表示更好, 所以我们采用邻接矩阵的图, 而不采用邻接表实现的图.

```cpp
namespace table {

template <class W>
struct Edge
{
    typedef Edge<W> self;

    int _dst;
    W _weight;
    std::shared_ptr<self> _next;

    Edge(int dst, const W& weight, const std::shared_ptr<self>& next)
        : _dst(dst), _weight(weight), _next(next)
    {
    }
};

template <class V, class W, bool Directed = false>
class Graph
{
   public:
    typedef Edge<W> Edge_Type;

    Graph(const V* data, int n)
    {
        _data.reserve(n);
        for (int i = 0; i < n; ++i)
        {
            _index_map[data[i]] = i;
            _data.emplace_back(data[i]);
        }

        _table.resize(n);
    }

    int GetVertexIndex(const V& z)
    {
        auto it = _index_map.find(z);

        if (it == _index_map.end())
            throw std::out_of_range("unordered_map::at: key not found");

        return _index_map[z];
    }

    void ModEdge(const V& x, const V& y, const W& w)
    {
        int src = GetVertexIndex(x);
        int dst = GetVertexIndex(y);

        auto node = std::make_shared<Edge_Type>(dst, w, _table[src]);
        _table[src] = node;

        if (Directed == false)
        {
            auto node = std::make_shared<Edge_Type>(src, w, _table[dst]);
            _table[dst] = node;
        }
    }

    void Print()
    {
        for (size_t i = 0; i < _data.size(); ++i)
        {
            std::cout << _data[i] << " -> ";
            auto curr = _table[i];
            while (curr)
            {
                std::cout << "(" << _data[curr->_dst] << ", " << curr->_weight << ") ";
                curr = curr->_next;
            }
            std::cout << '\n';
        }
    }

   private:
    std::vector<V> _data;
    std::unordered_map<V, int> _index_map;
    std::vector<std::shared_ptr<Edge_Type>> _table;
};

void TestGraph()
{
    std::vector<std::string> a{"张三", "李四", "王五", "赵六"};
    Graph<std::string, int> g(a.data(), a.size());
    g.ModEdge("张三", "李四", 100);
    g.ModEdge("张三", "王五", 200);
    g.ModEdge("王五", "赵六", 30);
    g.Print();
}

}  // namespace table
```

```shell
[whisper@starry-sky build]$ ./a.out
张三 -> (王五, 200) (李四, 100) 
李四 -> (张三, 100) 
王五 -> (赵六, 30) (张三, 200) 
赵六 -> (王五, 30) 
[whisper@starry-sky build]$ 
```

## 图的遍历

图的遍历有两种, 深度优先遍历和宽度优先遍历, 这两个遍历的概念在此略过, 算法库(基础算法讲了BFS, 回溯说了DFS)中有相应的介绍.

- 广度优先遍历

  ![image-20250512175525224](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250512175525288.png)

  我们借助于队列, 先把起点`A`压入, 为了避免环路, 我们将`visited`, 访问标记数组中的`A`对应的零位置标记为真, 表示已经访问过了. 之后, 由`A`找到与之相连的`B, C, D`将其压入队列, 标记`visited`, 并将`A`弹出, 一直循环, 直到队列为空.

  下面我们就邻接矩阵实现的图写一个bfs

  ```cpp
  void bfs(const V& start)
  {
      int size = _data.size();
      int src = GetVertexIndex(start);
      std::vector<bool> visited(size, false);
  
      visited[src] = true;
      std::queue<int> q;
      q.push(src);
  
      while (!q.empty())
      {
          int n = q.size();
          for (int i = 0; i < n; ++i)
          {
              int from = q.front();
              q.pop();
  
              for (int lead = 0; lead < size; ++lead)
              {
                  if (_matrix[from][lead] == MAX_W)
                      continue;
                  if (visited[lead] == true)
                      continue;
  
                  q.push(lead);
                  visited[lead] = true;
              }
          }
      }
  }
  ```
  
  大概就是这个意思, 不太好打印, 我就不加打印了, `i`循环是用来控制层数的
  
  ![image-20250512195856896](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250512195857117.png)
  
  如果它不讲究层数, 把`for i ← 0 to n`去掉也行.
  
  到对应层数的时候, 把这一层放到`vector`返回就行
  
- 深度优先遍历

  ![image-20250512200958212](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250512200958280.png)

  这也没什么好说的, 直接写.

  ```cpp
  void _dfs(int src, std::vector<bool>& visit)
  {
      visit[src] = true;
  
      for(int i = 0; i < _data.size(); ++i)
      {
          if(visit[i] == true) continue;
          if(_matrix[src][i] == MAX_W) continue;
  
          dfs(i, visit);
      }
  }
  
  void dfs(const V& start)
  {
      std::vector<bool> visit(_data.size(), false);
      _dfs(GetVertexIndex(start), visit);
  }
  ```

最后我们再说一个稍微要注意的事, 一次`bfs, dfs`不一定能遍历完全部的顶点, 因为可能这个图并不是连通图, 此时你在外面以`visit`为驱动进行遍历就行了.就是外面再套个循环, `visit`还为假就说明还未访问, 从这里为起点重新进行遍历.

## 最小生成树

让我们先回顾一下逻辑关系, 无向图, 连通图, 生成树, 最小生成树

连通图是无向图中的概念, 有向图的那个叫做强连通图, 生成树是边数目最小的连通图, 最小生成树是边权和最小的生成树.

连通图中的每一棵生成树，都是原图的一个极大无环子图，即：从其中删去任何一条边，生成树就不在连通；反之，在其中引入任何一条新边，都会形成一条回路.

若连通图由n个顶点组成，则其生成树必含n个顶点和n-1条边. 因此构造最小生成树的准则有三条：

- 只能使用图中的边来构造最小生成树
- 只能使用恰好n-1条边来连接图中的n个顶点
- 选用的n-1条边不能构成回路

最小生成树有两个对应的算法, 分别是 Kruskal 算法 , Prim 算法, 这两个算法都采用了逐步求解的贪心策略.  贪心算法库里面也有, 这里不说了.   

### Kruskal 算法 

`Kruskal`算法的思路是, 先把边以边权为比较值放入小根堆, 之后每次从小根堆里面拿出来一条边, 因为是小根堆, 所以边权就是小的, 这样那就是边权最小的. 在这个过程中, 为了避免成环, 在正式从堆里取边之前, 先准备一个并查集, 将图中的每个顶点作为独立的一棵树存到并查集里面, 之后在进行正式逻辑时, 从堆里取出的边先看看它的两个顶点是否已经在并查集的同一棵树里面, 在, 那就不能用这个边, 用了就会成环, 不在, 那就把整个边选上来.

![image-20250512204833603](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250512204833879.png) 

这个是算法导论里面的配图, 首先以边权为比较值把边放进小根堆里, 然后发现, `h, g`不相连(通过并查集), 那就确定有这条边, 并把`h, g`对应的树在并查集合并, 然后取出第二小的边, 对应上图的`b`, `i, c`通过并查集发现并不存在路径, 在当前的子图中, 于是就确定这个边, 并把`i, c`这两个集合合并, 一直重复, 直到选出`n - 1`条边, 或者选完了, 但没到达`n - 1`, 说明这不是连通图.

```cpp
Graph() = default;

void _ModEdge(int src, int dst, const W& w)
{
    _matrix[src][dst] = w;

    // 如果是有向图
    if (Directed == false)
        _matrix[dst][src] = w;
}

void ModEdge(const V& x, const V& y, const W& w)
{
    int src = GetVertexIndex(x);
    int dst = GetVertexIndex(y);

    _ModEdge(src, dst, w);
}

int Kruskal(self& minTree)
{
    using namespace std;

    self ans(_data.data(), _data.size());

    int size = _data.size();
    priority_queue<Edge, vector<Edge>, greater<Edge>> heap;
    for(int i = 0; i < size; ++i)
    {
        for(int j = 0; j < size; ++j)
        {
            if(_matrix[i][j] != MAX_W)
            {
                heap.emplace(i, j, _matrix[i][j]);
            }
        }
    }

    int ret = 0;
    UnionFindSet<int> ufs(size);
    while(!heap.empty())
    {
        Edge top = heap.top();
        heap.pop();

        if(ufs.IsInSameSet(top._src, top._dst)) continue;

        ++ret;
        ufs.Union(top._src, top._dst);
        ans._ModEdge(top._src, top._dst, top._weight);
    }

    if(ret == size - 1)
        minTree = ans;

    return ret - (size - 1);
}
```

有可能不是连通图, 也就是根本没有生成树, 此时那就怎么也拿不出`n - 1`个边, 那此时就返回一个负数, 能找到会对输出型参数赋值, 并返回零

```cpp
void TestGraphMinTree()
{
    const char* str = "abcdefghi";
    Graph<char, int> g(str, strlen(str));
    g.ModEdge('a', 'b', 4);
    g.ModEdge('a', 'h', 8);
    // g.ModEdge('a', 'h', 9);
    g.ModEdge('b', 'c', 8);
    g.ModEdge('b', 'h', 11);

    g.ModEdge('c', 'i', 2);
    g.ModEdge('c', 'f', 4);
    g.ModEdge('c', 'd', 7);
    g.ModEdge('d', 'f', 14);
    g.ModEdge('d', 'e', 9);
    g.ModEdge('e', 'f', 10);
    g.ModEdge('f', 'g', 2);
    g.ModEdge('g', 'h', 1);
    g.ModEdge('g', 'i', 6);
    g.ModEdge('h', 'i', 7);
    Graph<char, int> kminTree;
    std::cout << "Kruskal:" << g.Kruskal(kminTree) << std::endl;
    kminTree.Print();
}
```

```shell
[whisper@starry-sky build]$ ./a.out
Kruskal:0
Vertex Index:
[0] a  [1] b  [2] c  [3] d  [4] e  [5] f  [6] g  [7] h  [8] i  

   0 1 2 3 4 5 6 7 8
0  # 4 # # # # # 8 #
1  4 # # # # # # # #
2  # # # 7 # 4 # # 2
3  # # 7 # 9 # # # #
4  # # # 9 # # # # #
5  # # 4 # # # 2 # #
6  # # # # # 2 # 1 #
7  8 # # # # # 1 # #
8  # # 2 # # # # # #
[whisper@starry-sky build]$ 
```

