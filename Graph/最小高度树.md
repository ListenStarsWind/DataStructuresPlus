# [最小高度树](https://leetcode.cn/problems/minimum-height-trees/)

![image-20250520195804135](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250520195804308.png)

## 题目解析

尽管这道题是我在深度优先搜索中挖出来的, 但在我看来, 放在这里远比放在DFS专题更合适, 所以我把它放在了这里. 这道题已经无法用传统的深搜或者暴搜进行解答了, 我们需要从图这种数据结构的本身特点来解答它.

力扣的官方题解我看了, 但那里面的数学证明实在令人头大, 我没有坚实的数学基础和相关技巧, 在这里, 我做不到像力扣那样那么严谨, 我想做的, 是利用现实生活中的例子, 尽量用感性的方式去理解解题过程的算法思想.

首先, 我们需要先把问题稍微转化一下, 题目说, 要找这样的一个顶点, 从这个顶点出发, 到最远(对这个顶点来说), 顶点的路径长度是最短的, 比如, 对于上图中的示例二来说, 如果我们以其中的各个顶点为起点, 就有

| 根节点 | 到达各点的距离                | 最大距离（树高度） |
| ------ | ----------------------------- | ------------------ |
| 0      | 0→3(1)→1(2), 2(2), 4(2), 5(3) | **3**              |
| 1      | 同上，对称                    | **3**              |
| 2      | 同上                          | **3**              |
| 3      | 直接邻接 0,1,2,4(1)，5(2)     | **2**              |
| 4      | 4→3(1)→0/1/2(2), 5(1)         | **2**              |
| 5      | 5→4(1)→3(2)→0/1/2(3)          | **3**              |

从一个顶点开始, 其构成的树高度最小, 这意味着什么? 这意味着它到各个点的距离都比较近.

这种区域, 如果从交通角度来说, 叫做交通枢纽, 是一个地区的交通中心.

我们知道, 武汉是中国的交通枢纽, 但它在地理位置上, 并不是中国的地理中心, 这是因为武汉有着发达的交通基础设施, 它到中国的各个地区, 所花费的代价都是比较小的.

所以, 对于本题来说, 我们实际上要找的, 是树的中心点.  在这里我们额外再补充一些信息, 身为中心点, 身为交通枢纽, 别的那些小城市, 你说没有直接到拉萨的道路, 可以, 没有问题, 但身为中心点, 你必须要肩负起连通最远的两个地方的能力, 武汉可以去拉萨, 可以去热河, 可以去香港. 对于树的中心点, 也是这样, 树的中心点, 必然处于全图最远两个顶点的连接路径上, 并且关于这个路径对称, 如果该路径是偶数长度的, 那么就会同时拥有两个中心点, 奇数的话, 那就只有一个.

## 算法原理

那怎么找中心点呢, 我们要向剥洋葱那样, 一层一层的把, 最外层的顶点, 也就是叶节点, 从图上剥离出来, 此时原本在里面的非叶节点就会变成叶节点, 然后你再把它们剥下来.

到这里, 我们先要知道, 该用什么来判断顶点是否是叶节点, 答案就是度, 那些度为一的节点, 不就是叶节点吗, 它们度为一, 意味着它们很偏僻, 已经不能继续往外走了, 是最外面的节点, 也就是叶节点.

每剥离一层叶节点, 就要更新与这些叶节点直接相连顶点的度, 当它们的度也变为一时, 就说明它们就成为了新的叶节点.  为了模拟出一层一层的感觉, 我们需要使用队列, 由叶节点向中心逼近. 在更新节点度的时候, 就把该节点放入队列, 作为下一层要剥离的叶节点.

在剥离叶节点的时候, 我们会遇到这样的一些节点, 它们和之前的, 或者说上一层的叶节点直接相连, 在减去上一层叶节点的度, 他的度仍旧不是一, 不是一, 意味着它不是叶节点, 所以我们就不能入队列, 当然, 这样解释起来并不让人感觉十分自然, 所以我会从两个角度来说, 对于这些节点来说, 为什么, 不能现在入队列

第一个角度, 是从图的连通性来说的, 一个顶点的度不为一, 这意味着它是对个路径的汇合点, 如果你现在把他剥离, 就相当于断开了路径, 图就变得不练通了, 这是从安全性的角度来说的.

第二个角度, 我们要知道, 我们找的是中心点, 中心点才是起点, 叶节点是终点, 从中心点的视角来看, 那些度不为一的顶点是分叉路, 我们的路径会分裂成多个, 然后去找具体的叶节点, 现在我们想要逆转这个过程, 所以既然大家是从这个岔路口分裂的, 那么回来的时候, 必须也要同时到达, 同时会和在这些分叉路口, 因此, 如果你先到了这个分叉路口, 那么就请你等一等, 等其它所有路径在这里会和, 同时所有路径在这里会和就意味着这个节点变成叶节点了. 这是从逻辑角度来说的. 就像是线程, 主线程同时fork出一堆线程, 到最后, 主线程必须death, 必须让所有线程join自己, 才能结束自身.

在最后, 我们说一下代码细节, 我们维护两个数据结构, 一个存储邻接表, 因为题目给的二维数组既不是理解表, 也不是邻接矩阵, 需要转化一下, 此次是一张一位数组, 记录各个节点的度. 然后, 先把叶节点入队列, 然后不断循环直至队列为空,  在其中有个细节需要注意, 因为题目最后要的是一个数组, 所以对于每一层, 剥离出来的叶节点, 也就是出队列的节点, 都需要用数组暂时存储一下, 那么最后一轮循环, 自然会把中心点存下来.    还有一个点需要注意, 在减节点度的时候, 最好是一遍判断一遍减, 减了之后如果等于一立刻进队列, 这是因为, 对于一个中心点的图, 最后由于只剩下一个顶点, 这个顶点的度会变成零, 所以如果先减完, 再判断是不是一, 那么就会错过它们.

最后注意一下边界条件, 如果图中的点全是中心点, 也就是`n=1, n=2`这两种情况, 那就直接返回吧.

## 代码编写

```cpp
class Solution {
    public:
    vector<int> findMinHeightTrees(int n, vector<vector<int>>& _edges) {
        if(n == 1) return {0};
        if(n == 2) return {0, 1}; 


        vector<int> degree(n);
        vector<vector<int>> edges(n);
        for(const auto& v : _edges)
        {
            int a = v[0], b = v[1];
            edges[a].push_back(b);
            edges[b].push_back(a);

            ++degree[a];
            ++degree[b];
        }

        queue<int> q;
        for(int i = 0; i < n; ++i)
        {
            if(degree[i] == 1)
            {
                q.push(i);
                --degree[i];
            }
        }

        vector<int> result;
        while(!q.empty())
        {
            vector<int> temp;

            int size = q.size();
            for(int i = 0; i < size; ++i)
            {
                int src = q.front();
                q.pop();
                temp.push_back(src);
                for(auto dst : edges[src])
                {
                    if(--degree[dst] == 1)
                    {
                        q.push(dst);
                    }
                }
            }

            swap(result, temp);
        }

        return result;
    }
};
```

 # 完

