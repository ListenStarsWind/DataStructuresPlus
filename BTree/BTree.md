# B树

## 引入

在之前我们已经学习了下面这些查找结构

| 查找算法                 | 数据格式要求 | 时间复杂度    |
| ------------------------ | ------------ | ------------- |
| 顺序查找                 | 无要求       | O(N)          |
| 二分查找                 | 有序         | O($\log_2 N$) |
| 二叉搜索树               | 无要求       | O(N)          |
| 二叉平衡树（AVL/红黑树） | 无要求       | O($\log_2 N$) |
| 哈希查找                 | 无要求       | O(1)          |

但它们的使用都建立在这样的一个前提下, 那就是处理的数据量并不是特别大, 能够一次性放进内存中, 也就是所谓的"内查找".  对于信息化时代来说, 充斥着各种各样的数据, 这些数据的量都很大, 全部放进内存中是不现实的, 因此我们就需要一种数据结构, 这种数据结构在内存中存储着数据的某些关键字, 但数据的主体并不在内存中, 而是在其他的存储媒介上, 比如, 磁盘, 为了能找到磁盘上的主体数据, 这种数据结构便被设计为`k-v`格式, `k`表示数据的特征关键字, `v`表示主体数据在磁盘上的索引.  

我们可以先使用手头上现有额数据结构, 比如, 平衡搜索树, 和哈希表, 对于哈希表, 我们就直接跳过了, 为什么呢? 因为当数据量很大时, 哈希冲突的频率将会显著增加, 从而造成搜索效率的低下. 

这样, 就剩下了二叉平衡树, 要严谨一下, 强调一下是二叉, 我们可以让二叉搜索树的`k`充当上文所说的数据关键字, `v`充当主体数据在磁盘上的索引. 于是, 就大概有下图.

![image-20250518204233021](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250518204233104.png)

不过上面这张图所采用的策略和上文稍有不同, 它连关键字都没存到内存里, 每个节点单纯只有磁盘索引, 每次关键字比对, 都是直接进行一次IO. 可能数据量实在太大了, 关键字都存不下. 所以内存里只有地址.

比如我们想看一下`5`在不在这棵树里, 那么我们先看根节点, 读磁盘发现根节点的关键字是`34`, `34`比`5`大, 所以我们去左子树, `0x90`指向`22`, 也比`5`大, 那么就继续往左边走, `0x6A`, 指向`5`, 那么就找到了.

每一层我们都需要读一下选中节点指向的磁盘上的关键字, 所以说我们将进行高度次IO, 此时对于现有的二叉平衡树就有一个问题, 那就是高度还是太高了, 诚然, 对于内存来说, 去找一个30层的节点并不是什么难事, 但对于IO来说, 所耗费的时间就不可忽略了.

对于磁盘来说, 真正耗时的部分是定位过程, 在这个过程中, 磁头会以不断摆动的方式确定自身的位置, 并依据文件系统给出的索引, 逐渐靠近目标位置. 具体内容我们不多说, 在Linux的原始文件系统中有相关的介绍

![image-20250518211853625](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250518211853890.png)

算法导论, 在第18章, B树的开头也做过相关的描述.

![image-20250518212020630](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250518212020909.png)  

既然二叉平衡树太高了, 那么多叉平衡树呢? 子树一多, 高度不就降下来了. 另外, 同样为了减小位置的移动次数, 这棵多叉二叉树的每个节点存的可不是一份数据的关键字和对应索引, 而是多份数据的关键字和对应的索引. 也就是说, B树的一个节点里面有多份数据.

1970年，R.Bayer 和 E.mccreight 提出了一种适合外查找的树，它是一种平衡的多叉树，称为B树(后面有一个B的改进版本B+树，然后有些地方的B树写的的是B-树，注意不要误读成"B减树")。一棵m阶(m>2)的B树，是一棵平衡的M路平衡搜索树，可以是空树或者满足一下性质：

1. 根节点至少有两个孩子  
2. 每个分支节点都包含k-1个关键字和k个孩子，其中 ceil(m/2) ≤ k ≤ m ceil是向上取整函数  
3. 每个叶子节点都包含k-1个关键字，其中 ceil(m/2) ≤ k ≤ m  
4. 所有的叶子节点都在同一层  
5. 每个节点中的关键字从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域划分
6. 每个结点的结构为：（n，A0，K1，A1，K2，A2，… ，Kn，An）其中，Ki(1≤i≤n)为关键字，且Ki<Ki+1(1≤i≤n-1)。Ai(0≤i≤n)为指向子树根结点的指针。且Ai所指子树所有结点中的关键字均小于Ki+1。n为结点中关键字的个数，满足ceil(m/2)-1≤n≤m-1。

先不要看规则, 规则太多了, 一起看看不出什么东西.

首先, B树有一个名为"分支因子"的重要参数, 通常记为`m`, 正如它的名字所言, "分支因子"描述了一棵B树到底有"多分叉", 一般而言, `m`的取值是`50-2000`, 具体配置视实际需求而定, 对于服务器来说, 一般配置为`1024`, 是一个程序员很熟悉的数字.

B树中的每个节点, 都被分为两层, 或者更直白的说, 有两个数组, 一个数组存放的是关键字, 及其对应的磁盘索引, 一个数组存放子节点的指针, 为了简化模型, 第一个数组, 我们暂且就认为是只放关键字, 而不放磁盘索引,  该数组中的关键字呈现升序摆列, 是将来进行路由选择的判断依据, 第一个数组中的每个有效元素, 都有与之对应的两个子节点, 因此, 第二个数组中的节点个数始终是第一个数组中关键字个数的加一.

![image-20250518214838363](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250518214838413.png)

在这张图中, `data1, data2, data3`就是对应的关键字, 在这里为了简化模型, 我们直接认为关键字就是数据本体, 所以用`data`做前缀, 实际上, 它(每个`data`)当然要有对应的磁盘索引 , 用来指引主体数据在磁盘的何处, `data1`左边是`child1`, 右边是`child2`, `data2`左边是`child2`, 右边是`child3`, `data3`左边是`child3`, 右边是`child4`. 

相当于一个顶点缝合了之前AVL或者红黑树中的多个节点, 当有个关键字从上面过来时, 我们首先通过一些手段(二分查找), 找到和关键字相近的`data`, (也有可能直接就找到这个关键字了那样就没有路由选择, 所以我们这里暂且不说),  比如说, 我想找的数字是`3`, 这三个数字分别是`1, 5, 9`, 那么我们找到最近的(最近的说法似乎不准确, 应该是小于该关键字的最大元素), `159`里面`59`都大于`3`, 所以这里找到的`data`就是`1`, 而`3`又在`1`的右边, 所以下一层就会从`1`的右边, 即`child2`出发.



